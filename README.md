# Тестовое задание на стажировку AppSecCloudCamp


## 1. Вопросы для разогрева

1.  Расскажите, с какими задачами в направлении безопасной разработки вы сталкивались?
2.  Если вам приходилось проводить security code review или моделирование угроз, расскажите, как это было?
3.  Если у вас был опыт поиска уязвимостей, расскажите, как это было?
4.  Почему вы хотите участвовать в стажировке?

----------

1.  **Security Code Review (Обзор кода на безопасность):** При этом процессе я анализирую исходный код программы или веб-приложения на предмет потенциальных уязвимостей. Это включает поиск небезопасных практик, использование уязвимых библиотек или функций, неадекватную обработку ввода данных и другие проблемы безопасности. В ходе такого обзора, я могу выделить участки кода, требующие улучшений, и предложить рекомендации по их исправлению.
    
2.  **Моделирование угроз:** Это процесс анализа системы или приложения на предмет потенциальных уязвимостей и возможных атак со стороны злоумышленников. Я могу помочь в выявлении слабых мест в системе и предложить методы их защиты. Это может включать в себя анализ архитектуры системы, выявление возможных угроз, определение их потенциальных последствий и разработку стратегий по их предотвращению.
    
3.  **Поиск уязвимостей:** В ходе этого процесса я могу использовать различные методы, включая сканирование уязвимостей, тестирование на проникновение (penetration testing), анализ протоколов и другие методы, чтобы обнаружить потенциальные уязвимости в системе или приложении. После обнаружения уязвимости я могу предложить рекомендации по их устранению или ограничению.
4.  Моя заинтересованность в участии в стажировке в области безопасной разработки программного обеспечения проистекает из моего желания улучшить свои навыки в этой области. Я хочу научиться использовать самые современные методы и инструменты для обеспечения безопасности программного обеспечения и помогать компаниям защищать свои системы от киберугроз. Кроме того, я считаю, что защита информации и данных пользователей является крайне важной и захватывающей областью, и я стремлюсь внести свой вклад в эту сферу.

----------

## 2. Security code review

### Часть 1. Security code review: GO

### Уязвимости:

1.  **SQL Injection (SQL инъекция)**:
    -   Строки запросов формируются напрямую из пользовательского ввода, что делает их подверженными SQL инъекциям. Уязвимые строки: 26.

### Последствия:

-   **SQL Injection**: Злоумышленник может внедрить вредоносный SQL-код в параметр `searchQuery`, что позволит ему выполнять произвольные SQL-запросы к базе данных. Это может привести к утечке конфиденциальных данных, искажению или удалению данных.

### Способы исправления:

1.  **Подготовленные запросы (Prepared Statements)**: Использование подготовленных запросов вместо формирования строки запроса из пользовательского ввода позволит избежать SQL инъекций.
2.  **Использование пакета database/sql с sql.DB и sql.Tx**: Использование параметризованных запросов через пакет database/sql поможет предотвратить SQL инъекции и обеспечить безопасное взаимодействие с базой данных.

### Почему лучше использовать подготовленные запросы:
Подготовленные запросы обрабатывают пользовательский ввод как данные, а не как часть команды SQL, избегая тем самым возможности внедрения зловредного кода. Это общепринятый и рекомендуемый подход к предотвращению SQL инъекций.

Вот исправленный фрагмент кода с использованием подготовленных запросов:

    func searchHandler(w http.ResponseWriter, r *http.Request) {
        if r.Method != "GET" {
            http.Error(w, "Method is not supported.", http.StatusNotFound)
            return
        }
    
        searchQuery := r.URL.Query().Get("query")
        if searchQuery == "" {
            http.Error(w, "Query parameter is missing", http.StatusBadRequest)
            return
        }
    
        query := "SELECT * FROM products WHERE name LIKE ?"
        rows, err := db.Query(query, "%"+searchQuery+"%")
        if err != nil {
            http.Error(w, "Query failed", http.StatusInternalServerError)
            log.Println(err)
            return
        }
        defer rows.Close()
    
        var products []string
        for rows.Next() {
            var name string
            err := rows.Scan(&name)
            if err != nil {
                log.Fatal(err)
            }
            products = append(products, name)
        }
    
        fmt.Fprintf(w, "Found products: %v\n", products)
    }
Этот код использует параметризованный запрос, в котором символ `?` заменяет пользовательский ввод. Таким образом, он защищен от SQL инъекций.

### Часть 2: Security code review: Python

### Пример №2.1

#### Уязвимость:

1.  **Injection (инъекция)**:
    -   Строка `output = Template('Hello ' + name + '! Your age is ' + age + '.').render()` подвержена уязвимости инъекции, поскольку данные `name` и `age` подставляются напрямую в строку без проверки их содержимого.

#### Последствия:

-   **Injection**: Злоумышленник может внедрить произвольный код или скрипты, передавая данные через параметры `name` и `age`. Это может привести к выполнению нежелательных операций на сервере или к утечке конфиденциальной информации.

#### Способы исправления:

1.  **Использование функций экранирования**: Использование функций экранирования, таких как `escape()` или `safe()`, для безопасной вставки данных в шаблон Jinja2.
2.  **Использование форматирования строк**: Вместо конкатенации строк можно использовать форматирование строк или метод `format()` для вставки данных в шаблон.

Почему лучше использовать функции экранирования:
Функции экранирования, предоставленные Jinja2, обеспечивают более надежную защиту от инъекций, так как они экранируют специальные символы, предотвращая внедрение нежелательного кода в результирующую строку.

    from flask import Flask, request
    from jinja2 import Template, escape
    
    app = Flask(__name__)
    
    @app.route("/page")
    def page():
        name = escape(request.values.get('name'))
        age = escape(request.values.get('age', 'unknown'))
        output = Template('Hello {{ name }}! Your age is {{ age }}.').render(name=name, age=age)
        return output
    
    if __name__ == "__main__":
        app.run(debug=True)

### Пример №2.2

#### Уязвимость:

1.  **Command Injection (инъекция команд)**:
    -   Строка `output = subprocess.check_output(cmd, shell=True, text=True)` подвержена уязвимости инъекции команд из-за того, что параметр `hostname` добавляется напрямую к команде `nslookup`.

#### Последствия:

-   **Command Injection**: Злоумышленник может использовать эту уязвимость для выполнения произвольных команд на сервере, что может привести к компрометации сервера или утечке конфиденциальной информации.

#### Способы исправления:

1.  **Использование модуля `socket`**: Использование модуля `socket` вместо вызова внешней утилиты `nslookup` для выполнения DNS-запросов.
2.  **Обеспечение безопасности вызова `subprocess`**: Если использование внешних утилит необходимо, следует использовать безопасные методы вызова subprocess с избеганием использования параметра `shell=True`.

Почему лучше использовать модуль `socket`:
Использование модуля `socket` обеспечивает более надежный и безопасный способ выполнения операций с сетью без риска инъекции команд.

    from flask import Flask, request
    import socket
    
    app = Flask(__name__)
    
    @app.route("/dns")
    def dns_lookup():
        hostname = request.values.get('hostname')
        try:
            ip_address = socket.gethostbyname(hostname)
            output = f"IP address for {hostname} is {ip_address}"
        except socket.error:
            output = "Failed to resolve hostname"
        return output
    
    if __name__ == "__main__":
        app.run(debug=True)
